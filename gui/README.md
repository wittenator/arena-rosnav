# VIS Project WS2021 - A drawing panel for easily designing scenarios

### Requirements
1. Install Ubuntu 18.04.
2. Install [Kivy](https://kivy.org/doc/stable/gettingstarted/installation.html#install-pip). <br />
`$ python -m pip install --upgrade pip setuptools virtualenv` <br />
`$ python -m virtualenv kivy_venv` <br />
`$ source $HOME/kivy_venv/bin/activate` <br />
`$ python -m pip install kivy[base] kivy_examples`
3. Clone the whole project.

### How to run
1. Upload an image of the map in the `input` folder inside of the root folder.
2. Activate the kivy environment. <br />
`$ source $HOME/kivy_venv/bin/activate`
3. Navigate inside the project root folder.
4. Execute the `paint.py` file. <br />
`$ python paint.py`
5. Generate a new scenario in the paint app. Look at the rules!
6. Execute the `parser.py` file. <br />
`$ python parser.py`
7. The generated json file will be saved under the name `new_scenario.json` in the `output` folder.
8. Copy and paste the json file in the folder `arena-rosnav/simulator_setup/scenerios/`.
9. Modify the `arena-rosnav/arena_bringup/launch/sublaunch/task_generator.launch` file, changing the name of the expected json file to `new_scenario.json`.
10. In `arena-rosnav` run for example `roslaunch arena_bringup start_arena_flatland.launch disable_scenario:="false" map_file:="map1" scenario_file:="new_scenario.json" local_planner:="teb" use_viz:=true rviz_file:=nav`. Please take a look at the section `Legend for the already tested maps` below.

### Folder structure
1. The root folder consist of both executable files `paint.py` and `parser.py`, as well as the ReadMe file.
2. The folder `input` inside of the root folder should be filled by the user before starting the program with the image of the map, for which scenarios have to be designed. <br />
**Attention:** Do not forget to adjust the name of the new map in the `paint.py` file!
3. The folder `output` inside of the root folder will be empty at first, but after the file `paint.py` has been run, it will fill with data and images from the painting program. The `parser.py` file will then use this information to generate the json file, which will also be saved in the same folder.

### Rules for using the paint program
1. The first thing to do is to set the number of obstacles, the resolution and the origin of the uploaded map.
2. From the dropdown button on the left should be chosed the obstacle type. After that obstacles if form of circles could be placed with a mouse click on the map. To change the radius of the obstacle, the clicked mouse could be moved left-right and the radius will accordingly get smaller-bigger. In the center of the new obstacle will appear an index, with which the obstacle will be saved. Different types of obstacles are supported in the same scenario.
3. When ready with the obstacles, click on the first button on the bottom left. From this point on the map could be positioned again with a mouse click watchers. To assign the watchers to obstacles the dynamically generated by the number of obstacles table on the right should be filled. In the same table should be also given the velocity for each obstacle, as well as its motion. The legend of the table per line from left to right is: obstacle index (look at the map) - obstacle velocity - watcher indices for this obstacle (to separate multiple watchers use comma without spaces in between -> example: '1,2') - motion for this obstacle (example 'yoyo').
4. When ready with the watchers and the information, click on the second button on the bottom. From now on with mouse click and drag could be drawn lines. This lines represents the trajectory of the obstacles. The start of each line will not be considered, since it always should be at the center of an obstacle. But the end of the line is important, since there will be the end point of the movement of the dynamic obstacle. Because there is now way to connect a line to its obstacle, it is important to draw the lines in the same order as the obstacle - so to start with drawing the motion for obstacle 0, then for obstacle 1 and so on.
5. When ready with the lines (waypoints), on the map could be clicked the start and position of the robot. It could be clicked only twice and the first click should be for the start position. The center of the visualized two circles will be then considered as the start and end position of the robot, so the radius doesn't matter.
6. When ready with the robot positions, click on the last button on the bottom to confirm that the scenario is now ready. No changes could be further made. The information from the paint app will be saved in files in the `output` folder. The information saved is still rough, so another python script `parser.py` should run after that to become the json file for the just generated scenario.
7. To make the user experience easier, there is a 'return' button. While placing the obstacles, the watchers, the waypoints or the robot positions, you can click on the button and you can start from the beginning of the current section. For example if you are currenly placing the watchers and you make a mistake, you can click on 'return' and you can start over with placing the watchers, without deleting the obstacles. Once you move forward to the waypoint, the watchers can not be changed anymore - if there is still a mistake, the programm should be started from the beginning. Be careful with the 'return' button while placing the obstacles. Since there are multiple available obstacle types, once you change the type of the obstacle to another, the obstacles from the first type can not be deleted anymore. The 'return' button will give you the chance to start over only with the current obstacle type.

### Legend for the already tested maps
1. map_small.png in paint.py -> resolution: 0.05; origin:(-6.0, -6.0) in the paint program -> ros launch with map_file:="map1"
2. map.png in paint.py -> resolution: 0.050000; origin: (-16.600000, -6.650000) in the paint program -> ros launch with map_file:="map0"

